Oracle ADW와 OpenAI를 활용한 RAG 기반 감염병 모니터링 챗봇 구축 보고서
프로젝트 개요

본 프로젝트는 Oracle 23ai Autonomous Data Warehouse(ADW)에 저장된 대규모 감염병 데이터를 사용자가 자연어 질문을 통해 실시간으로 조회하고 분석할 수 있는 지능형 챗봇 시스템을 구축하는 것을 목표로 한다.
Retrieval-Augmented Generation (RAG) 아키텍처를 기반으로, 사용자의 질문 의도를 파악하여 동적으로 SQL 쿼리를 생성하고, 데이터베이스 조회 결과를 바탕으로 신뢰성 있는 답변을 제공하는 시스템을 구현하였다.
이 과정에서 발생한 다양한 기술적 문제들과 해결 과정을 상세히 기술하여 안정적인 AI 서비스 구축의 전 과정을 기록한다.

1. 시스템 아키텍처

본 챗봇 시스템은 사용자의 요청을 안전하고 효율적으로 처리하기 위해 여러 계층으로 구성된 표준 웹 서비스 아키텍처를 채택하였다.


사용자 (User): 웹 브라우저를 통해 시스템의 프론트엔드에 접속하여 자연어로 질문을 입력한다.

Nginx (Reverse Proxy): 시스템의 최전방에 위치한 관문(Gateway) 역할을 수행한다. 외부의 모든 웹 요청(80/443 포트)을 수신하여, 요청 경로(URL Path)에 따라 내부의 적절한 백엔드 서비스로 안전하게 전달(Proxying)한다.
이를 통해 로드 밸런싱, SSL 암호화 처리, 보안 강화 등의 이점을 얻는다.

백엔드 서버 (OCI Compute VM): Oracle Cloud Infrastructure(OCI)의 가상 머신에 구축된 핵심 로직 수행부이다. 두 개의 독립적인 서비스로 구성된다.

NER 서비스 (포트 8000): 사용자의 질문을 받아 '질병명', '지역', '기간' 등 의미 있는 핵심 단어(개체명)를 추출하는 자연어(NER) 전처리 모듈이다.

챗봇 RAG 서비스 (포트 8001): main.py로 구현된 프로젝트의 핵심으로, NER을 거친 질문을 받아 RAG 파이프라인을 실행한다. OpenAI API를 호출하여 SQL을 생성하고, ADW에 쿼리를 실행하여 최종 결과를 반환한다.

OpenAI API: 외부 대규모 언어 모델(LLM)인 GPT-4o를 활용한다. 데이터베이스 스키마 정보와 사용자 질문을 바탕으로 Oracle SQL 쿼리를 생성하는 두뇌 역할을 수행한다.

Oracle 23ai ADW: 모든 감염병 통계 원본 데이터가 저장된 클라우드 데이터 웨어하우스이다. 챗봇이 생성한 SQL 쿼리를 받아 실행하고, 그 결과를 백엔드 서비스로 반환한다.

2. 핵심 기술 스택

클라우드 인프라: Oracle Cloud Infrastructure (OCI) Compute VM (Oracle Linux)

리버스 프록시: Nginx

백엔드 프레임워크: FastAPI (Python 기반의 고성능 웹 프레임워크)

애플리케이션 서버: Uvicorn

서비스 관리 시스템: systemd (Linux 표준 서비스 관리 도구)

데이터베이스: Oracle 23ai Autonomous Data Warehouse (ADW)

AI / LLM: OpenAI GPT-4o

주요 Python 라이브러리:

llama-index, langchain: LLM 연동 및 RAG 파이프라인 구성을 위한 프레임워크

sqlalchemy, oracledb: Oracle DB 연결 및 쿼리 실행

transformers, torch: 로컬 NER 모델 구동

3. RAG 챗봇 핵심 구현 내용 및 문제 해결 과정

본 챗봇은 단순히 라이브러리 기능에 의존하는 것을 넘어, 실제 운영 환경에서 발생하는 다양한 호환성 및 설정 문제를 해결하는 과정에서 고도화되었다. 초기 접근 방식의 한계를 극복하고 안정적인 수동 Text-to-SQL 파이프라인을 구축한 전 과정을 상세히 기술한다.

가. 초기 접근 방식의 한계와 난관
초기에는 LlamaIndex 라이브러리가 제공하는 자동화된 NLSQLTableQueryEngine을 사용하여 빠르고 간편하게 Text-to-SQL 기능을 구현하고자 하였다. 하지만 OCI VM, Oracle ADW, 최신 라이브러리 버전이 복합적으로 작용하며 예상치 못한 수많은 문제에 직면했다.

데이터베이스 연결 문제: 가장 먼저 발생한 문제는 애플리케이션과 ADW 간의 연결 설정이었다.

ORA-12154 오류: tnsnames.ora 파일의 DSN(서비스 이름)을 해석하지 못하는 문제로, TNS_ADMIN 환경 변수 설정, Wallet 파일 내부의 sqlnet.ora 경로 수정 등 Oracle Thick 모드 드라이버의 복잡한 설정 과정을 거쳐 해결하였다.

DPY-6000: Listener refused connection 오류: DSN, 자격 증명, Wallet 파일이 모두 정확함에도 불구하고 리스너가 연결을 거부하는 문제에 직면했다. 이는 최종적으로 OCI 클라우드의 네트워크 접근 제어 목록(ACL) 방화벽 설정이 누락되었기 때문임을 확인하고, VM의 공인 IP를 허용 목록에 추가하여 해결하였다.

Thick 모드 vs Thin 모드: test_adw.py를 통한 Thick 모드 연결은 성공했으나, main.py의 Thin 모드 연결은 SSL_SERVER_DN_MATCH 옵션과의 충돌로 계속 실패했다. 이 경험을 통해 현재 환경에서는 Thick 모드가 더 안정적이라는 결론을 내리고, main.py의 접속 방식을 Thick 모드로 통일하였다.

LlamaIndex 호환성 문제: DB 연결에 성공한 후에는 LlamaIndex 라이브러리 자체의 호환성 문제가 발생했다.

테이블/뷰 자동 감지(Reflection) 실패: SQLDatabase 객체 생성 시 include_tables 파라미터로 테이블/뷰 목록을 전달했음에도, 라이브러리가 DB 메타데이터를 조회하는 과정에서 알 수 없는 오류로 객체를 찾지 못하는 문제가 반복되었다.

해결 시도: 이 문제를 해결하기 위해 root_path, openapi_prefix 등 FastAPI의 리버스 프록시 관련 설정을 변경하고, SQLDatabase에 스키마 정보를 직접 주입(table_info)하는 등 다양한 방법을 시도했으나 모두 실패했다. 이는 LlamaIndex의 자동화 기능이 현재 환경과 맞지 않음을 시사했다.

나. 최종 해결책: 수동 Text-to-SQL 파이프라인 구축
자동화 엔진의 한계를 명확히 인지하고, RAG의 모든 단계를 직접 제어하는 수동 파이프라인으로 아키텍처를 변경하였다. 이 방식은 안정성과 정확성을 극대화하는 최선의 선택이었다.

LLM 직접 호출 및 SQL 추출:

LlamaIndex의 NLSQLTableQueryEngine을 더 이상 사용하지 않고, OpenAI LLM 객체를 직접 호출하는 방식으로 변경했다.

AI가 생성한 자연어 답변에서 SQL 쿼리 부분만 정확하게 분리해내기 위해, re (정규표현식) 라이브러리를 사용한 extract_sql_from_response 함수를 구현했다. 이 함수는 여러 줄로 구성된 복잡한 서브쿼리도 안정적으로 추출할 수 있도록 설계되었다.

DB 직접 실행:

추출된 SQL 쿼리는 SQLAlchemy의 text() 구문을 통해 DB 엔진에서 직접 실행된다. 이로써 라이브러리의 중간 계층 없이 가장 직접적이고 안정적인 데이터 조회 경로를 확보했다.

다. 고도화된 프롬프트 엔지니어링 전략
수동 파이프라인의 성공은 AI에게 얼마나 정확하고 상세한 지시를 내리는가에 달려있다. 본 프로젝트에서는 AI의 SQL 생성 능력을 극대화하기 위해 다음과 같은 프롬프트 엔지니어링 기법을 적용했다.

행동 규칙 (Behavioral Rules): AI가 쿼리를 생성할 때 반드시 지켜야 할 행동 지침을 명시적으로 지시했다.

출력 형식 제어: 하나의 SQL 쿼리만 생성, 다른 설명이나 사과 제외, SELECT로 시작, 세미콜론 제외 등의 규칙을 통해 AI의 출력 형식을 표준화하여 SQL 추출 과정의 안정성을 높였다.

오류 방지 규칙: 컬럼 별칭(Alias)은 영어 사용, NULL 값 데이터 제외 등의 규칙을 추가하여, 특정 DB 환경에서 발생할 수 있는 오류를 AI가 스스로 피해가도록 유도했다.

스키마 정보 강화 (Schema Enrichment): DB 뷰(View)의 구조를 CREATE TABLE 형식으로 제공할 때, AI의 이해를 돕는 추가 정보를 주석(Comment)으로 삽입했다.

유사어/동의어 명시: 동정균주명 컬럼 설명에 Also called ''균'', ''병원균'' 과 같은 주석을 추가하여, 사용자가 사용하는 다양한 용어를 AI가 DB 컬럼과 매핑할 수 있도록 했다.

SQL 문법 유도: FETCH 문법이 일으키는 미묘한 오류를 피하기 위해, To get the top N results, please use a subquery with ROWNUM 이라는 주석을 추가하여 AI가 더 안정적인 ROWNUM 서브쿼리를 사용하도록 직접 안내했다.

라. 안정적인 서비스 운영 환경 구축
개발된 챗봇 애플리케이션이 24시간 안정적으로 운영될 수 있도록 인프라 환경을 구축했다.

nohup으로 실행 : chatbot과 ner 서비스를 nohup으로 실행했다. 이를 통해 PuTTY 접속이 끊겨도 서버가 계속 실행되어 서비스의 가용성을 극대화했다.

Nginx 리버스 프록시: 외부에는 표준 웹 포트(80)만 노출하고, 내부적으로는 Nginx가 각 서비스의 포트(8000, 8001)로 요청을 분배하는 리버스 프록시 구조를 완성했다. 이를 통해 보안을 강화하고, 향후 SSL 인증서 적용 및 로드 밸런싱 확장을 위한 기반을 마련했다.

4. 결론

본 프로젝트는 Oracle ADW의 정형 데이터를 자연어로 탐색하는 RAG 기반 챗봇을 성공적으로 구축하였다. 이 과정에서 DB 연결, 라이브러리 호환성, 서버 배포, 네트워크 설정 등 실제 AI 서비스를 개발하며 마주할 수 있는 복합적인 문제들을 체계적으로 해결하였다.

특히, 자동화된 도구의 한계를 인지하고 수동으로 Text-to-SQL 파이프라인을 제어하는 방식으로 전환한 것과, AI의 성능을 극대화하기 위해 상세한 프롬프트 엔지니어링 기법을 적용한 것이 프로젝트 성공의 핵심 요인이었다. 최종적으로 nohup와 Nginx를 통해 구축된 안정적인 서비스 환경은, 본 챗봇이 향후 실제 감염병 모니터링 시스템의 일부로 확장될 수 있는 견고한 기반이 될 것이다.
